
@using CleanArchitecture.Blazor.Application.Features.Drivers.DTOs
@using CleanArchitecture.Blazor.Application.Features.Drivers.Mappers
@using CleanArchitecture.Blazor.Application.Features.Drivers.Queries.GetMy
@using CleanArchitecture.Blazor.Server.UI.Pages.Drivers.Components

@inherits MudComponentBase
@inject IStringLocalizer<Drivers> L
@* @attribute [Authorize(Policy = Permissions.Drivers.View)] *@





<MudGrid>
    <MudItem xs="12" md="12">

@*         Required="false"
        RequiredError="@L["Driver is required!"]" *@
        <MudSelect T="string"
                   Value="UserId"
                   ValueChanged="OnDriverChanged">
            <MudSelectItem Value=0>Select a Driver</MudSelectItem>

            @foreach (var doc1type in drivers)
            {
                <MudSelectItem Value="doc1type.UserId">@doc1type.DisplayName</MudSelectItem>
            }
        </MudSelect>
    </MudItem>


</MudGrid>

@code {

    [Parameter]
    public EventCallback<string> UserIdChanged { get; set; }

    [CascadingParameter]
    private UserProfile? UserProfile { get; set; }

    private string _userId;
    [Parameter]
    public string UserId
    {
        get => _userId;
        set
        {
            if (_userId != value)
            {
                _userId = value;
                UserIdChanged.InvokeAsync(value);
            }
        }
    }


    private IEnumerable<DriverDto> drivers = default!;
    private GetMyDriversQuery GetMyDriversQuery = null;

    public DriverDto SelectedDriver { get; set; } = null!;
    private void OnDriverChanged(string id)
    {
        UserId = id;
        SelectedDriver = drivers.FirstOrDefault(m => m.UserId == id);
    }

    bool isDisabled => (SelectedDriver is null);

    protected override async Task OnInitializedAsync()
    {
        GetMyDriversQuery= new() { CurrentUser = UserProfile };
        drivers = await LoadDrivers();
    }

    private async Task<IEnumerable<DriverDto>> LoadDrivers()
    {
        var result = await Mediator.Send(GetMyDriversQuery).ConfigureAwait(false);
        return result;
    }
}
